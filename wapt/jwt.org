#+title: Jwt
#+author: gabriel

JWT (JSON Web Token) is a JSON-encoded piece of information typically used for authentication and information exchange. JWTs are secured by digital signatures, ensuring data integrity and authentication.

The primary purpose of JWTs is to facilitate user authentication and authorization. Additionally, it is possible to securely transfer information between various services.

[[./imgs/jwt.png]]

*header* ->
The header specifies the type of token and the signing algorithm used. It usually contains a JSON object like this:
#+begin_src python
{
  "alg": "HS256",
  "typ": "JWT"
}
#+end_src

*payload* ->
 The payload contains the data to be carried inside the token. This data can include information such as user ID and the token's expiration date.
 #+begin_src python
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
 #+end_src

 *signature* ->
 The signature is created by combining and signing the header and payload. The signature helps verify that the JWT has not been tampered with and is trustworthy.

** jwt vs other token formats
JWTs are lighter and easier to use compared to other token formats like SAML (Security Assertion Markup Language) and OAuth. Here are some differences between these formats:
- JWT: Uses JSON format, making it lighter and more readable. Easily transported within HTTP headers and URLs.
- SAML: An XML-based format that is more complex. Used in applications with high security and validation requirements.
- OAuth: An authorization protocol that can be used with JWTs. Commonly used to grant third-party applications access.

  When a JWT is created, the header and payload are defined in JSON format and encoded using base64URL encoding. These two components are then combined and signed using a specified algorithm. The signature is used to verify the integrity and origin of the token.


When a JWT is received, the header and payload are decoded using base64URL encoding, and the signature is verified. This validation confirms that the token has not been tampered with and is trustworthy.

JWTs are widely used in user authentication and authorization processes. When a user logs in, a JWT is created that carries this user's specific authorization information. This token is sent to the server with each request, and the server verifies the token to check the user's permissions.

JWTs are also used to securely share information between different services. For example, in a microservices architecture, one service can securely pass user information to another service via JWT.

* jwt vulns
While JWTs are a powerful tool for secure information exchange and authentication, they can have various security vulnerabilities if misconfigured or weakened security practices are used.

*signature verification flaws* ->
 Failing to properly verify JWT signatures can allow attackers to tamper with the token.

*weak signature keys* ->
 Using weak or easily guessable signature keys can lead to JWTs being easily cracked and altered.

*algorithm confusion* ->
Misconfiguration of algorithm types can be exploited to bypass JWT validation processes.

*kid paramater vulnerabilities* ->
 By injecting the kid parameter and using other techniques, JWT signatures can be bypassed.

*replay attacks* ->
The reusable nature of JWTs allows attackers to use the same token repeatedly.

*token lifetime and validity issues* ->
Tokens with long validity periods increase security risks.

*JWKS spoofing* ->
Bypassing JWT validation using forged keys.

*attacks using jku and x5u headers* ->
 Attacks carried out through external URLs in JWT headers.

* tools
*jwt-tool* ->
jwt_tool is a powerful tool used to analyze, create, and perform various attacks on JWTs. This tool is used to test the weaknesses of JWT and discover security vulnerabilities.
https://github.com/ticarpi/jwt_tool

*jwt-pwn* ->
jwt-pwn is another popular tool used to check JWT signatures, test algorithm confusion, and perform various attacks.
https://github.com/mazen160/jwt-pwn

*jwtXploiter* ->
jwtXploiter is used to manipulate JWTs, bypass signature verification processes, and discover vulnerabilities.
 https://github.com/DontPanicO/jwtXploiter

** signature verification attacks
The signature verification processes of JWTs are crucial for ensuring their security. Signature verification vulnerabilities can compromise the integrity and trustworthiness of JWTs

 These attacks include bypassing signatures using the none algorithm and weak signature verification processes.

** capture of signature keys
 Weak signature keys can lead to JWTs being easily cracked and manipulated. Such attacks involve capturing weak keys through brute force attacks and exploiting misconfigured keys.

** algorithm confusion
Confusion in the algorithm header of JWTs can be used to bypass signature verification processes. Algorithm confusion attacks are carried out by altering the algorithm information in the header part of the JWT.

** kid parameter vulnerabilites
JWT signatures can be bypassed by injecting the kid parameter and using other techniques. These attacks are carried out by exploiting the kid parameter in the JWT header.


JWTs can also be vulnerable to other security issues such as replay attacks, token lifetime, and revocation problems. These attacks can occur when JWTs are reused or valid for long periods. Moreover, JWKS spoofing and attacks using jku/x5u headers fall into this category.

* signature verification attack
The signature of a JWT (JSON Web Token) is a critical component to ensure the integrity and authenticity of the token. However, if misconfigured or if weak security measures are taken, JWT signatures can be manipulated by attackers.

The integrity of JWTs is ensured by combining the header and payload sections and protecting them with a signature. The signature is created using a specific algorithm and is used to verify that the JWT has not been tampered with.

The generated signature is appended to the JWT, forming the final token in header.payload.signature format.

** common algorithms
*HMAC (Hash-based Message Authentication Code)* ->
HMAC is a symmetric algorithm and uses the same secret key (private key) for both signing and verification.

*RSA (Rivest-Shamir-Adleman)* ->
RSA is an asymmetric algorithm and uses different keys for signing and verification. The private key is used for signing, while the public key is used for verification.

** none algorithm attack
One of the simplest attacks encountered in JWT verification processes is the none algorithm attack. In this attack, the signature part of the JWT is completely bypassed.
#+begin_src python
{
  "alg": "none",
  "typ": "JWT"
}
#+end_src

The signature part of the JWT is completely removed, transforming the token into the following format ->
: eyJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIn0.

* capturing the signature key
Signature keys used to secure JWTs guarantee the integrity and authenticity of the token. However, if these keys are not strong enough or properly protected, attackers can capture them.

Signature keys can be easily guessed by attackers if they are not complex and strong enough. Weak keys generally appear in the following forms:

*simple and short keys* ->
Examples include common passwords like "password," "123456," or "secret."

*personal information* ->
 Keys derived from users' names, birthdates, or other personal information.

*previously compromised keys* ->
 Keys that were leaked in previous security breaches and are reused.

 Attacker can use varous tools and techniques to identift and try exploit weak keys ->

 *dictionary attacks* ->
guessing keys using predefined list of common passwords

 *brute force attacks* ->
 cracking keys by trying all possible combinations

 *rainbow tables* ->
 using precomputed hash values to perform hash comparisons

** dictionary attacks
JWT ->
: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

Dictionary Create a dictionary file, dictionary.txt, containing common passwords. You can also use password lists available on the internet.

python script for dictionary attack ->
#+begin_src python
import jwt
from jwt.exceptions import InvalidSignatureError

jwt_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
header, payload, signature = jwt_token.split('.')

with open('dictionary.txt', 'r') as file:
    words = file.readlines()

for word in words:
    word = word.strip()
    try:
        decoded = jwt.decode(jwt_token, word, algorithms=['HS256'])
        print(f"Secret found: {word}")
        print(f"Decoded JWT: {decoded}")
        break
    except InvalidSignatureError:
        continue
#+end_src

This code tries every word in the dictionary.txt file as the JWT's signature key. If it finds the correct key, it successfully decodes the JWT and prints out the correct key.

** brute force attacks
Brute force attacks aim to find the correct key by trying all possible combinations of characters. This method can take a significant amount of time, depending on the length and complexity of the key.

JWT ->
: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

python script for brute force attack ->
#+begin_src python
import jwt
from jwt.exceptions import InvalidSignatureError
import itertools
import string

jwt_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
header, payload, signature = jwt_token.split('.')

charset = string.ascii_lowercase  # 'abcdefghijklmnopqrstuvwxyz'

def brute_force_attack(jwt_token, max_length):
    for length in range(1, max_length + 1):
        for attempt in itertools.product(charset, repeat=length):
            secret = ''.join(attempt)
            try:
                decoded = jwt.decode(jwt_token, secret, algorithms=['HS256'])
                print(f"Secret found: {secret}")
                print(f"Decoded JWT: {decoded}")
                return
            except InvalidSignatureError:
                continue

brute_force_attack(jwt_token, 3)
#+end_src

This code tries all lowercase letter combinations of lengths 1 to 3 to guess the JWT's signature key. If it finds the correct key, it successfully decodes the JWT and prints out the correct key.

* Algorithm confusion
One of the common attacks that jeopardize the security of JWTs (JSON Web Tokens) is the algorithm confusion attack. This attack involves misconfiguring or exploiting the signing algorithm of a JWT.

Algorithm confusion attacks occur when an attacker tricks the server into verifying a JWT’s signature using a different algorithm than the website developers intended.

*symmetric algorithms* ->
 HS256: Use the same key for both signing and verification. This key must be kept secret like a password.

*asymmetric algorithms* ->
RS256: Use different keys for signing and verification. A private key signs the token, and a public key verifies it. The public key can be shared, while the private key must be kept secret.

Algorithm confusion vulnerabilities arise from incorrect implementations of JWT libraries. Many libraries choose the algorithm based on the alg parameter in the JWT header.

For example, in the simplified code snippet below, the signature verification is done for both RS256 and HS256 algorithms:
#+begin_src python
def verify(token, secretOrPublicKey):
    algorithm = token.getAlgHeader()
    if algorithm == "RS256":
        # Use the provided key as an RSA public key
    elif algorithm == "HS256":
        # Use the provided key as an HMAC secret key
#+end_src

If developers assume that the server will only accept tokens signed with RS256 and use a fixed public key, attackers could sign the token with HS256 and verify it using the fixed public key as the HMAC secret key.

** obtain the server public key
 This key is often available at a standard endpoint like /jwks.json or /.well-known/jwks.json.

 Servers sometimes store their public keys as JSON Web Key (JWK) objects at a standard endpoint. For example:
 #+begin_src python
{
  "keys": [
    {
      "kty": "RSA",
      "e": "AQAB",
      "kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab",
      "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
    }
  ]
}
 #+end_src
** convert the public key to a proper format
Convert the obtained JWK (JSON Web Key) to the required format (e.g., PEM).

Use the JWT Editor extension for Burp Suite to convert the public key from JWK format to X.509 PEM format:
- Go to the JWT Editor Keys tab in Burp Suite.
- Create a new RSA Key and paste the JWK.
- Convert it to PEM format and use this key to create the signature.

** create a malicious JWT
Modify the payload and set the alg header to HS256.

Modify the alg parameter in the JWT header to HS256 and manipulate the payload.

** sign the token with HS256
Use the public key as the secret to sign the token.

Sign the token using the HS256 algorithm, using the public key as the secret key:
#+begin_src python
import jwt

header = {
    "alg": "HS256",
    "typ": "JWT"
}
payload = {
    "sub": "administrator"
}
token = jwt.encode(payload, "PUBLIC_KEY_AS_SECRET", algorithm="HS256", headers=header)
print(token)
#+end_src

By following these steps, we can circumvent the JWT verification process and gain unauthorized access.

* jwt header parameter injections
According to the JWS (JSON Web Signature) specification, only the alg header parameter is mandatory.

However, in practice, JWT headers (also known as JOSE headers) often contain many other parameters. These parameters are particularly appealing to attackers.

- *jwk (JSON Web Key)* ->
   Provides an embedded JSON object representing the key.

- *jku (JSON Web Key Set URL)* ->
  Provides a URL pointing to a set of keys.

- *kid (Key ID)* ->
   Provides an identifier to determine the correct key when multiple keys are used. This parameter may match with the kid depending on the key format.

   The JWS specification states that servers can embed their public keys directly into the token using the jwk header parameter in JWK format.

JWK (JSON Web Key) is a standardized format to represent keys as a JSON object. Here is an example of this format:

#+begin_src javascript
{
    "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
    "typ": "JWT",
    "alg": "RS256",
    "jwk": {
        "kty": "RSA",
        "e": "AQAB",
        "kid": "ed2Nf8sb-sD6ng0-scs5390g-fFD8sfxG",
        "n": "yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9m"
    }
}
#+end_src

Ideally, servers should use only a limited list of public keys. However, misconfigured servers might sometimes use any key embedded within the jwk parameter.

** attack steps
- Install the JWT Editor extension in Burp Suite and navigate to the JWT Editor Keys tab.
- Generate a new RSA key.
- Send a request containing a JWT to Burp Repeater.
- Switch to the JSON Web Token tab and modify the token's payload as desired.
- Click the Attack button and select Embedded JWK. Choose the RSA key you generated.
- Send the request to the server and examine how the server responds.

You can also perform this attack manually. However, when adding the jwk header parameter, you need to match the JWT's kid header parameter with the kid parameter of the embedded key.

** injecting self-signed JWTs with the JKU parameter
ome servers use the jku (JWK Set URL) header parameter instead of the jwk header parameter, allowing a URL reference that contains a set of keys. When verifying the signature, the server retrieves the key from this URL.

A JWK Set is a JSON object containing an array of JWKs representing different keys.

#+begin_src javascript
{
    "keys": [
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "75d0ef47-af89-47a9-9061-7c02a610d5ab",
            "n": "o-yy1wpYmffgXBxhAUJzHHocCuJolwDqql75ZWuCQ_cb33K2vh9mk6GPM9gNN4Y_qTVX67WhsN3JvaFYw-fhvsWQ"
        },
        {
            "kty": "RSA",
            "e": "AQAB",
            "kid": "d8fDFo-fS9-faS14a9-ASf99sa-7c1Ad5abA",
            "n": "fc3f-yy1wpYmffgXBxhAUJzHql79gNNQ_cb33HocCuJolwDqmk6GPM4Y_qTVX67WhsN3JvaFYw-dfg6DH-asAScw"
        }
    ]
}
#+end_src

These key sets are sometimes publicly served through standard endpoints like /jwks.json or /.well-known/jwks.json.

** injecting self-signed JWTs with the KID parameter
Servers may use many cryptographic keys to sign various types of data, not just JWTs. Therefore, a JWT header might contain a kid (Key ID) parameter to specify which key should be used for signature verification.

*** attack steps
If the kid parameter is vulnerable to path traversal, an attacker can trick the server into using an arbitrary file from the file system as the verification key.
#+begin_src javascript
{
    "kid": "../../path/to/file",
    "typ": "JWT",
    "alg": "HS256",
    "k": "asGsADas3421-dfh9DGN-AFDFDbasfd8-anfjkvc"
}
#+end_src

This is particularly dangerous if the server also supports JWTs signed with symmetric algorithms. In this case, an attacker can point the kid parameter to a predictable static file and sign the JWT with a secret key matching the content of that file.

If the server stores verification keys in a database, the kid header parameter can also be a vector for SQL injection attacks.

** other interessting JWT header parameters
*cty (Content Type)*: Indicates the media type of the content in the JWT payload. It's often stripped from the header, but the software library used might still support it. If you find a way to bypass signature verification, try injecting the cty header to change the content type to application/xml or application/x-java-serialized-object.

*x5c (X.509 Certificate Chain)*: Conveys the X.509 public key certificate or certificate chain corresponding to the key used to digitally sign the JWT. This header parameter can be used to inject self-signed certificates


eyJ0eXAiOiJKV1QiLCJhbGciOiJub25lIn0.eyJpYXQiOjE3NTkyNDEwMjksImV4cCI6MTc1OTI0NDYyOSwic3ViIjoyfQ.
